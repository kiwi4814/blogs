+++
title = "单元测试之二：代码用例"
date = "2021-09-05T22:40:15+08:00"
tags = ["单元测试"]
slug = "/unitTest2"
draft = false
categories = ["技术"]

series = ["单元测试"]

+++

## 一、引入

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
</dependency>
```

从*`dependency:tree`*中我们可以看到：

![image-20210527095848554](../../../../slipbox/ReadingNotes/极客时间学习/数据结构与算法之美/Users/heqifeng/Library/Application Support/typora-user-images/image-20210527095848554.png)

里面默认依赖了我们会可能会用到包：

- `JUnit`，标准的单元测试Java应用程序；
- `Spring Test & Spring Boot Test`，对Spring Boot应用程序的单元测试提供支持；
- `Mockito`, Java mocking框架，用于模拟任何Spring管理的Bean，比如在单元测试中模拟一个第三方系统Service接口返回的数据，而不会去真正调用第三方系统；
- `AssertJ`，一个流畅的assertion库，同时也提供了更多的期望值与测试返回值的比较方式；
- `Hamcrest`，库的匹配对象（也称为约束或谓词）；
- `JsonPath`，提供类似XPath那样的符号来获取JSON数据片段；
- `JSONassert`，对JSON对象或者JSON字符串断言的库。

此外，在后续的使用过程中，为了在单元测试中实现各种各样的功能，我们还将引入一下jar包：

**1. MyBatis-Test，用于在单元测试中测试持久层**

```xml
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter-test</artifactId>
    <version>1.3.5</version>
    <scope>test</scope>
</dependency>
```

**2. 用于JSON数据的断言**

```xml
<dependency>
  <groupId>com.jayway.jsonpath</groupId>
  <artifactId>json-path-assert</artifactId>
  <version>${jsonPath.assert.version}</version>
</dependency>
```

**3. powermock，用于mock静态方法、枚举、构造器等**

```xml
<dependency>
  <groupId>org.powermock</groupId>
  <artifactId>powermock-module-junit4</artifactId>
  <version>${powermock.version}</version>
  <scope>test</scope>
</dependency>
<dependency>
  <groupId>org.powermock</groupId>
  <artifactId>powermock-api-mockito</artifactId>
  <version>${powermock.version}</version>
  <scope>test</scope>
</dependency>
```

**4. JUnitParams，用于参数化测试的辅助**

 ```xml
 <dependency>
 		<groupId>pl.pragmatists</groupId>
 		<artifactId>JUnitParams</artifactId>
 		<version>1.1.1</version>
 		<scope>test</scope>
 </dependency>
 ```



## 二、知识准备

### 1. `Junit`基本注解

`Junit4`单元测试主流程中的主要注解有：

- `@BeforeClass` 
- `@Before`
- `@Test` 
- `@After` 
- `@AfterClass` 
- `@Ignore`

其中， `@BeforeClass`和`@AfterClass`在每个类加载的开始和结束时运行，必须为静态方法；而`@Before`和`@After`则在每个测试方法开始之前和结束之后运行。执行次序是`@BeforeClass` -> `@Before` -> `@Test` -> `@After` -> `@Before` -> `@Test` -> `@After` -> `@AfterClass`。`@Ignore`会被忽略。

### 2. `Assert`断言工具

 `Junit4`提供了一个Assert类，Assert类中定义了很多静态方法来进行断言。

- `assertEquals("message",A,B)`，判断A对象和B对象是否相等，这个判断在比较两个对象时调用了equals()方法。

- `assertSame("message",A,B)`，判断A对象与B对象是否相同，使用的是==操作符。

- `assertTrue("message",A)`，判断A条件是否为真。

- `assertFalse("message",A)`，判断A条件是否不为真。

- `assertNotNull("message",A)`，判断A对象是否不为null。

- `assertArrayEquals("message",A,B)`，判断A数组与B数组是否相等。

### 3. `MockMvc`

MockMvc，从字面上来看指的是模拟的MVC，即其可以模拟一个MVC环境，向Controller发送请求然后得到响应。

利用MockMvc我们可以模拟get、post、文件上传、session和cookie等，并且对返回结果进行处理。这里贴出一些常用的代码段：

```java
        // 模拟get请求
        mockMvc.perform(MockMvcRequestBuilders.get("/jqxx/get?jqbh={jqbh}", "jqbh"));
        // 模拟post请求
        mockMvc.perform(MockMvcRequestBuilders.post("/jqxx/put/{jqbh}", "202105212106A"));
        // 模拟文件上传：
        mockMvc.perform(MockMvcRequestBuilders.fileUpload("/fileupload").file("file", "文件内容".getBytes("utf-8")));
        // 设置返回格式为JSON：
        mockMvc.perform(MockMvcRequestBuilders.get("/user/{id}", 1).accept(MediaType.APPLICATION_JSON));
        // 模拟HTTP请求头：
        mockMvc.perform(MockMvcRequestBuilders.get("/user/{id}", 1).header("name", "values"));
        // 模拟发送一个message参数，值为hello
        mockMvc.perform(MockMvcRequestBuilders.get("/hello").param("message", "hello"));
        // 模拟提交一个checkbox值，name为hobby，值为sleep和eat
        mockMvc.perform(MockMvcRequestBuilders.get("/saveHobby").param("hobby", "sleep", "eat"));
        // 模拟Session和Cookie：
        mockMvc.perform(MockMvcRequestBuilders.get("/index").sessionAttr("name", "value"));
        mockMvc.perform(MockMvcRequestBuilders.get("/index").cookie(new Cookie("name", "value")));
        // 设置请求的Content-Type：
        mockMvc.perform(MockMvcRequestBuilders.get("/index").contentType(MediaType.APPLICATION_JSON_UTF8));
        // 期望成功调用，即HTTP Status为200：
        mockMvc.perform(MockMvcRequestBuilders.get("/user/{id}", 1)).andExpect(MockMvcResultMatchers.status().isOk());
        // 期望返回内容是application/json：
        mockMvc.perform(MockMvcRequestBuilders.get("/user/{id}", 1)).andExpect(MockMvcResultMatchers.content().contentType(MediaType.APPLICATION_JSON));
        // 检查返回JSON数据中某个值的内容：
        mockMvc.perform(MockMvcRequestBuilders.get("/user/{id}", 1)).andExpect(MockMvcResultMatchers.jsonPath("$.username").value("mrbird"));

```

### 4. `Mockito`

官方文档：[Mockito (Mockito 2.28.2 API) (javadoc.io)](https://javadoc.io/static/org.mockito/mockito-core/2.28.2/org/mockito/Mockito.html)

Mockito 是一个强大的用于 Java 开发的模拟测试框架, 通过 Mockito 我们可以创建和配置 Mock 对象, 进而简化有外部依赖的类的测试。目前在 Java 中主流的 mock 测试工具有 Mockito、JMock、EasyMock..等，而 SpringBoot 目前內建的是 Mockito 框架。使用 Mockito 的大致流程如下：

- 创建外部依赖的 Mock 对象，然后将此 Mock 对象注入到测试类中。
- 执行测试代码。
- 校验测试代码是否执行正确。

#### （1）@InjectMocks

**创建一个实例，简单的说是这个Mock可以调用真实代码的方法，其余用@Mock（或@Spy）注解创建的mock将被注入到用该实例中。**

#### （2）@Mock

**对函数的调用均执行mock（即虚假函数），不执行真正部分。**

#### （3）@Spy

**对函数的调用进行监视，优先执行打桩的代码，否则执行真实的代码**

## 三、单元测试

### 1. 使用Mockito测试服务层代码

```java
@RunWith(MockitoJUnitRunner.class)
public class AlarmInfoTestServiceTest {

    @InjectMocks
    private AlarmInfoTestServiceImpl alarmInfoTestService;

    @Mock
    private RbacCurrentUserService currentUserService;

    @Mock
    private ErsZxxxExtMapper ersZxxxExtMapper;

    @Test
    public void save() throws Exception {
        AuthUser user = new AuthUser();
        user.setCode("poc-hqf");
        user.setName("000000");
        when(currentUserService.findCurrentAuthUser()).thenReturn(user);
        when(ersZxxxExtMapper.selectAllFjhmAndzxzt()).thenReturn(new ArrayList<>());
        List<ZxFjZtDTO> zxFjZtDTOS = alarmInfoTestService.saveTest("111");
        Assert.assertEquals(zxFjZtDTOS.size(), 0);

    }
}

```



### 2. 使用MyBatisTest测试持久层代码

```java
@RunWith(SpringRunner.class)
@ContextConfiguration(classes = {ErsZxxxExtMapper.class})
public class TestMapperTest extends BaseMapperConfig {

    @Resource
    private ErsZxxxExtMapper ersZxxxExtMapper;

    @Test
    public void selectZxxxList() {
        List<ZxFjZtDTO> results = ersZxxxExtMapper.selectAllFjhmAndzxzt();
        System.out.println("==========Mapper Test Result==========");
        Assert.assertEquals(results.size(),25);
    }
}

```

```java
@MybatisTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@ActiveProfiles("dev")
@MapperScan({"com.kedacom.ers.**.mapper"})
public class BaseMapperConfig {
}
```





### 3. 测试Controller

```java
@RunWith(MockitoJUnitRunner.class)
@WebMvcTest(secure = false)
//@ContextConfiguration(classes = {AlarmInfoTestController.class})
public class AlarmInfoControllerTest2 {

    private MockMvc mockMvc;

    @Mock
    private RbacCurrentUserService currentUserService;

    @InjectMocks
    private AlarmInfoTestController alarmInfoTestController;
		
  // 初始化默认的mockMvc行为
    @Before
    public void setup() {
        this.mockMvc = standaloneSetup(alarmInfoTestController)
                .alwaysDo(print())
                .alwaysExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8))
                .alwaysExpect(status().isOk())
                .build();
    }

    @Test
    public void save() throws Exception {
        AuthUser user = new AuthUser();
        user.setCode("poc-hqf");
        user.setName("000000");
        given(this.currentUserService.findCurrentAuthUser()).willReturn(user);

        String result = mockMvc.perform(post("/jqxx/save2")
                .accept(MediaType.APPLICATION_JSON_UTF8)
                .param("deptCode", "111")
                .contentType(MediaType.APPLICATION_JSON_UTF8))
                .andExpect(status().isOk())
                .andReturn().getResponse().getContentAsString();
    }
}
```

使用mockMvc时针对controller不同的参数类型如何入参：

#### @RequestParam

测试类：

```java
@RestController
@RequestMapping("/jqxx")
@Slf4j
public class AlarmInfoTestController {
    @GetMapping(value = "/list")
    public ResponseMessage<String> getJqxxList(@RequestParam(value = "jqbh") String jqbh, @RequestParam(value = "deptCode") String deptCode) {
        log.info("this is a test=={}=={}", jqbh, deptCode);
        return ResponseMessage.ok("Succeed");
    }
}
```

方法1:

```java
    @Test
    public void getJqxxList() throws Exception {
        String result = mockMvc.perform(get("/jqxx/list")
                .param("jqbh", "202105161215A").param("deptCode", "5e10e7d4c651428a86977f5fe0947204")
                .contentType(MediaType.APPLICATION_JSON_UTF8))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.result", is("Succeed1")))
                .andReturn().getResponse().getContentAsString();
    }
```

方法2:

```java
    @Test
    public void getJqxxList() throws Exception {
        String result = mockMvc.perform(get("/jqxx/list?jqbh={jqbh}&deptCode={deptCode},", "202105161215A", "5e10e7d4c651428a86977f5fe0947204")
                .contentType(MediaType.APPLICATION_JSON_UTF8))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.result", is("Succeed1")))
                .andReturn().getResponse().getContentAsString();
    }
```

方法3:

```java
    @Test
    public void getJqxxList() throws Exception {
        MultiValueMap<String, String> params = new LinkedMultiValueMap<>();
        params.add("jqbh", "202105161215A");
        params.add("deptCode", "5e10e7d4c651428a86977f5fe0947204");
        String result = mockMvc.perform(get("/jqxx/list")
                .params(params)
                .contentType(MediaType.APPLICATION_JSON_UTF8))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.result", is("Succeed1")))
                .andReturn().getResponse().getContentAsString();
    }
```

#### @PathVariable

```java
    @Test
    public void getJqxxList2() throws Exception {
        String result = mockMvc.perform(get("/jqxx/get/{jqbh}?deptCode={deptCode},", "202105161215A", "5e10e7d4c651428a86977f5fe0947204")
                .contentType(MediaType.APPLICATION_JSON_UTF8))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.result", is("Succeed1")))
                .andReturn().getResponse().getContentAsString();
    }
```



####  @RequestBody

- 使用JSON的方式传递

  ```json
      @Test
      public void getJqxxList1() throws Exception {
          String jsonStr = "{\"jqbh\":\"202105161215A\",\"departmentCode\":\"5e10e7d4c651428a86977f5fe0947204\"}";
          String result = mockMvc.perform(get("/jqxx/list")
                  .content(jsonStr.getBytes(StandardCharsets.UTF_8))
                  .contentType(MediaType.APPLICATION_JSON_UTF8))
                  .andExpect(status().isOk())
                  .andExpect(jsonPath("$.result", is("Succeed1")))
                  .andReturn().getResponse().getContentAsString();
      }
  
      @Test
      public void getJqxxList2() throws Exception {
          ErsJqxxConditonQuery query = new ErsJqxxConditonQuery();
          query.setJqbh("202105161215A");
          query.setDepartmentCode("5e10e7d4c651428a86977f5fe0947204");
          String userJson = JSONUtil.toJsonStr(query);
          String result = mockMvc.perform(get("/jqxx/list")
                  .content(userJson.getBytes(StandardCharsets.UTF_8))
                  .accept(MediaType.APPLICATION_JSON_UTF8)
                  .contentType(MediaType.APPLICATION_JSON_UTF8))
                  .andExpect(status().isOk())
                  .andExpect(jsonPath("$.result", is("Succeed1")))
                  .andReturn().getResponse().getContentAsString();
      }
  ```



### 4. 综合测试

**有时候，我们并不想单纯的测试controller或者service，我们只想把一些复杂的或者中间件服务的代码进行Mock，其余的均模拟真实的环境进行测试，也就是从controller到service到mapper进行全方位的测试。这时候我们需要使用Spring-Boot-Test提供的MockBean和SpyBean注解来实现。**



#### @Mock与@MockBean的区别

@Mock是Mockito提供的注解，用于快速的模拟所需要的bean。

@MockBean的作用是允许在Spring ApplicationContext中添加Mockito模拟。它的含义是如果上下文中存在与声明的类兼容的 bean，则用 mock 替换它。否则它会将 mock 作为 bean 添加到上下文中。

#### @Mock和@Spy的区别

 对于未指定mock的方法，spy默认会调用真实的方法，有返回值的返回真实的返回值，而mock默认不执行，有返回值的，默认返回null。

- spy和mock生成的对象不受spring管理

- spy调用真实方法时，其它bean是无法注入的，要使用注入，要使用SpyBean

- SpyBean和MockBean生成的对象受spring管理，相当于自动替换对应类型bean的注入，比如@Autowired等注入

#### 代码用例

```java
@RunWith(SpringRunner.class)
@WebMvcTest(secure = false)
//@ContextConfiguration(classes = {AlarmInfoTestController.class})
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@ActiveProfiles("dev")
@MapperScan({"com.kedacom.ers.**.mapper"})
@AutoConfigureMybatis
public class AlarmInfoControllerTest3 {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private RbacCurrentUserService currentUserService;
    @SpyBean
    private AlarmInfoTestServiceImpl alarmInfoTestService;

    @Test
    public void save() throws Exception {
        AuthUser user = new AuthUser();
        user.setCode("poc-hqf");
        user.setName("000000");
        when(currentUserService.findCurrentAuthUser()).thenReturn(user);

        String result = mockMvc.perform(post("/jqxx/save3")
                .accept(MediaType.APPLICATION_JSON_UTF8)
                .param("deptCode", "111")
                .contentType(MediaType.APPLICATION_JSON_UTF8))
                .andExpect(status().isOk())
                .andReturn().getResponse().getContentAsString();

    }
}
```

### 5. PowerMock介绍

PowerMock可以和Mockito配合使⽤，版本之间的对应关系如下：

![PowerMock-Mockito](../../../../slipbox/ReadingNotes/极客时间学习/数据结构与算法之美/Users/heqifeng/Pictures/PowerMock-Mockito.png)

由于PowerMock的机制是反射，所以除了⼀些特殊的地⽅需要使⽤到PowerMock的，其余测试仍然推荐使⽤ Mockito。具体如下：

- Mock Final类

  ```java
      @Test
      public void testMockFinalMethod() {
          Student student = PowerMockito.mock(Student.class);
          String mockFinalMethod = "mockFinalMethod";
          when(student.getFinalMethod()).thenReturn(mockFinalMethod);
          assertThat(student.getFinalMethod(), is(mockFinalMethod));
      }
  ```

- Mock 私有⽅法 

- Mock 静态⽅法

- Mock 构造器

  ```java
      @Test
      public void testMockConstructMethod() throws Exception {
          Student student1000 = new Student(1000);
          PowerMockito.whenNew(Student.class).withArguments(10).thenReturn(student1000);
          Student student10 = new Student(10);
          assertThat(student10.getAge(), is(1000));
      }
  ```

- Mock 枚举Enum

  ```java
      @Test
      public void testMockEnum() {
          PersonType personType = PowerMockito.mock(PersonType.class);
          Whitebox.setInternalState(PersonType.class, "N", personType);
          when(personType.getType()).thenReturn("mockN");
          assertThat(PersonType.N.getType(), is("mockN"));
          assertThat(PersonType.S.getType(), is("student"));
      }
  ```

  

**代码⽤例：**

```java
@RunWith(PowerMockRunner.class)
@PrepareForTest({MockMvcServiceImpl.class, StaticUtil.class, ShardCacheRunner.class, IPUtil.class})
public class PowerMockServiceTest {

    @InjectMocks
    private MockMvcServiceImpl mockMvcService;

    @Mock
    private RbacCurrentUserService currentUserService;

    @Mock
    private ErsZxxxExtMapper ersZxxxExtMapper;

    /**
     * 如果不需要mock静态方法，直接使用即可
     */
    @Test
    public void powermock_serviceUseStatic_givenNumber() throws Exception {
        when(mockMvcService.codeWithStatic(anyString())).thenReturn("2");
        when(ersZxxxExtMapper.selectDeviceIdByUserId(anyString())).thenReturn("1030");
        String ip = mockMvcService.codeWithStatic("testTest");
        //Assert.assertEquals("192.168.42.68", ip);
    }

    /**
     * mock静态方法
     */
    @Test
    public void powermock_staticPublic_givenNumber() throws Exception {
        PowerMockito.spy(StaticUtil.class);
        List<String> test = new ArrayList<>();
        test.add("111");
        PowerMockito.doReturn(test).when(StaticUtil.class, "getPublicInfo");
        List<String> publicInfo = StaticUtil.getPublicInfo();
        Assert.assertEquals(1, publicInfo.size());
    }


    /**
     * mock私有方法
     */
    @Test
    public void powermock_staticPrivate_givenNumber() throws Exception {
        PowerMockito.spy(StaticUtil.class);
        List<String> test = new ArrayList<>();
        test.add("111");
        PowerMockito.doReturn(test).when(StaticUtil.class, "getPrivateInfo");
        List<String> publicInfo = StaticUtil.getPrivateInfoUsePublic();
        Assert.assertEquals(1, publicInfo.size());
    }


}

```



## 参考文档

[Spring-Documentation - 15.6.1 Server-Side Tests](https://docs.spring.io/spring-framework/docs/4.3.18.RELEASE/spring-framework-reference/html/integration-testing.html#spring-mvc-test-server)

[MockMvc (Spring Framework 4.3.18.RELEASE API)](https://docs.spring.io/spring-framework/docs/4.3.18.RELEASE/javadoc-api/index.html?org/springframework/web/socket/sockjs/transport/TransportType.html)

[mybatis-spring-boot-test-autoconfigure – Introduction](http://mybatis.org/spring-boot-starter/mybatis-spring-boot-test-autoconfigure/index.html)

[Optimizing Spring Integration Tests | Baeldung](https://www.baeldung.com/spring-tests)

[Integration Testing in Spring | Baeldung](https://www.baeldung.com/integration-testing-in-spring)

[Testing in Spring Boot | Baeldung](https://www.baeldung.com/spring-boot-testing#integration-testing-with-datajpatest)

[json-path/JsonPath: Java JsonPath implementation (github.com)](https://github.com/json-path/JsonPath)

[hehonghui/mockito-doc-zh: Mockito框架中文文档 (github.com)](https://github.com/hehonghui/mockito-doc-zh#0)
