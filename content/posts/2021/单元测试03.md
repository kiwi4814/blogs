+++
title = "单元测试之三：参数化测试"
date = "2021-09-08T22:40:15+08:00"
tags = ["单元测试"]
slug = "/unitTest3"
draft = false
categories = ["技术"]

series = ["单元测试"]

+++



## 一、参数化测试

有时候对于同一个单元测试，我们并不希望只测试一组参数，而是期望对传入的不同参数返回不同的结果。参数化测试允许开发人员使用不同的值反复运行同一个测试。

## 二、在系统中集成参数化测试

参数化测试主要有如下步骤实现：

1. **用 @RunWith(Parameterized.class) 来注释 test 类；**

2. **实现 @Parameters注解的公共静态方法，返回值是一个数组对象，作为测试的参数集合；**

3. **创建一个公共的构造函数，它接受和一行测试数据相等同的东西；**

4. **为每一列测试数据创建一个实例变量；**

5. **用实例变量作为测试数据的来源来创建你的测试用例。**

首先，我们在上节中使用Mockito时Test类的注解已经变成了**`MockitoJUnitRunner`**，为了能兼容Mockito的使用，我们需要手动初始化Mockito，代码如下：

```java
@RunWith(SpringRunner.class)
public class AlarmInfoServiceImplDESTest {
    @InjectMocks
    private AlarmInfoServiceImpl alarmInfoService;
    @Before
    public void initMocks() {
        MockitoAnnotations.initMocks(this);
    }
    @Test
    public void testMethod() throws Exception {
     
    }
}
```

在此基础上，我们实现集成了Parameterized.class的单元测试类：

```java
@RunWith(Parameterized.class)
public class AlarmInfoServiceImplParameterizedTest {
    @InjectMocks
    private AlarmInfoServiceImpl alarmInfoService;

    @Before
    public void initMocks() {
        MockitoAnnotations.initMocks(this);
    }


    private String cellPhone;
    private String bh;

    public AlarmInfoServiceImplParameterizedTest(String cellPhone, String bh) {
        this.cellPhone = cellPhone;
        this.bh = bh;
    }


    @Parameterized.Parameters(name = "{index}: des({0}_{1})")
    public static Iterable<Object[]> data() {
        return Arrays.asList(new Object[][]{
                        {"13764589436", "202102164582A"},
                        {"13764589437", "202102164582B"},
                        {"13764589438", "202102164582C"},
                        {"13764589439", "202102164582D"},
                        {"13764589440", "202102164582E"}
                }
        );
    }

    @Test
    public void AESTest() throws Exception {
        ReflectionTestUtils.setField(alarmInfoService, "H5SlatKey", "htGyqmtq2IdlA7Y2");
        ReflectionTestUtils.setField(alarmInfoService, "h5MessagePrefix", "【deptName】您的报警信息已经收到，点击查看}");
        String encrypt = alarmInfoService.encrypt(cellPhone, bh);
        BaseH5DecodeModel decrypt = alarmInfoService.decrypt(encrypt);
        assertEquals(bh, decrypt.getAlarmCode());
        assertEquals(cellPhone, decrypt.getCellPhone());
        assertEquals(encrypt, decrypt.getPath());
    }


}
```



## 三、使用JUnitParams

但是，使用上面的方法实现起来未免太麻烦，这意味着一个类中只能写一个单元测试，而通常情况下对于同一个方法，我们可能有很多的单元测试用例，要传递不同的参数，全部应用参数化测试的时候工作量太大。为此，我们引入`JUnitParams`来解决这个问题。

官方文档对于`JUnitParams`的介绍只有一句话：

> Parameterised tests that don't suck.

直译的话就是让你的单元测试不会很差劲。这个工具主要针对JUnit4，因为Junit5已经对参数化测试做了优化，功能更加强大和便捷。

JUnitParams和默认的Parameterized.class的区别之处在于：

- 参数定义在测试方法参数中，而不是类的字段
- 不需要构造函数来设置参数
- 可以在一个类中使用非参数化方法进行参数化测试
- 参数可以写在csv文件或者单独的类中提供
- 参数提供程序类可以具有尽可能多的参数提供方法，以便分组不同的案例
- 可以有一个提供参数的测试方法
- 您可以在IDE中看到实际参数值(在JUnit的Parametrised中，它只有连续数量的参数)

这里列出一些常见的写法：

1. 通过注解来实现

   ```java
   @RunWith(JUnitParamsRunner.class)
   public class AlarmInfoServiceImplJUnitParamsTest {
       @InjectMocks
       private AlarmInfoServiceImpl alarmInfoService;
   
       @Before
       public void initMocks() {
           MockitoAnnotations.initMocks(this);
       }
   
   
       @Test
       @Parameters({"13764589436|202102231536A", "13764589437|202102231536A"})
       public void AESTest2(String cellPhone, String bh) throws Exception {
           ReflectionTestUtils.setField(alarmInfoService, "H5SlatKey", "htGyqmtq2IdlA7Y2");
           ReflectionTestUtils.setField(alarmInfoService, "h5MessagePrefix", "【deptName】您的报警信息已经收到，点击查看}");
           String encrypt = alarmInfoService.encrypt(cellPhone, bh);
           BaseH5DecodeModel decrypt = alarmInfoService.decrypt(encrypt);
           assertEquals(bh, decrypt.getAlarmCode());
           assertEquals(cellPhone, decrypt.getCellPhone());
           assertEquals(encrypt, decrypt.getPath());
       }
   
   
   }
   
   ```

   

2. 通过方法来实现

   ```java
   @RunWith(JUnitParamsRunner.class)
   public class AlarmInfoServiceImplJUnitParamsTest {
       @InjectMocks
       private AlarmInfoServiceImpl alarmInfoService;
   
       @Before
       public void initMocks() {
           MockitoAnnotations.initMocks(this);
       }
   
       public static Iterable<Object[]> data() {
           return Arrays.asList(new Object[][]{
                           {"13764589436", "202102164582A"},
                           {"13764589437", "202102164582B"},
                           {"13764589438", "202102164582C"},
                           {"13764589439", "202102164582D"},
                           {"13764589440", "202102164582E"}
                   }
           );
       }
   
       @Test
       @Parameters(method = "data")
       public void AESTest2(String cellPhone, String bh) throws Exception {
           ReflectionTestUtils.setField(alarmInfoService, "H5SlatKey", "htGyqmtq2IdlA7Y2");
           ReflectionTestUtils.setField(alarmInfoService, "h5MessagePrefix", "【deptName】您的报警信息已经收到，点击查看}");
           String encrypt = alarmInfoService.encrypt(cellPhone, bh);
           BaseH5DecodeModel decrypt = alarmInfoService.decrypt(encrypt);
           assertEquals(bh, decrypt.getAlarmCode());
           assertEquals(cellPhone, decrypt.getCellPhone());
           assertEquals(encrypt, decrypt.getPath());
       }
   }
   ```

   

3. 通过csv文件实现

   ```java
   @RunWith(JUnitParamsRunner.class)
   public class AlarmInfoServiceImplJUnitParamsTest {
       @InjectMocks
       private AlarmInfoServiceImpl alarmInfoService;
   
       @Before
       public void initMocks() {
           MockitoAnnotations.initMocks(this);
       }
   
   
       @Test
       @FileParameters("classpath:test.csv")
       public void AESTest1(String cellPhone, String bh) throws Exception {
           ReflectionTestUtils.setField(alarmInfoService, "H5SlatKey", "htGyqmtq2IdlA7Y2");
           ReflectionTestUtils.setField(alarmInfoService, "h5MessagePrefix", "【deptName】您的报警信息已经收到，点击查看}");
           String encrypt = alarmInfoService.encrypt(cellPhone, bh);
           BaseH5DecodeModel decrypt = alarmInfoService.decrypt(encrypt);
           assertEquals(bh, decrypt.getAlarmCode());
           assertEquals(cellPhone, decrypt.getCellPhone());
           assertEquals(encrypt, decrypt.getPath());
       }
   }
   ```

   

## 参考文档

https://www.liaoxuefeng.com/wiki/1252599548343744/1304065789132833

[Writing Parameterized Tests With JUnit 4 (testwithspring.com)](https://www.testwithspring.com/lesson/writing-parameterized-tests-with-junit-4/)

[Introduction to JUnitParams | Baeldung](https://www.baeldung.com/junit-params)
